# -*- coding: utf-8 -*-
"""backtrader.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cLrQcY1ebMURJP1utQ2PVchKePM2EHYt
"""

# !pip install backtrader

import yfinance as yf
import backtrader as bt
import pandas as pd
import itertools
from datetime import datetime

# Importing necessary python libraries for this project
import pandas as pd
import numpy as np
import yfinance as yf
import matplotlib.dates as mpl_dates
import matplotlib.pyplot as plt

plt.rcParams['figure.figsize'] = [12, 7]
plt.rc('font', size=14)

# Create two functions to calculate if a level is SUPPORT or a RESISTANCE level through fractal identification
def is_Suppport_Level(df, i):
  support = df['Low'][i] < df['Low'][i - 1] and df['Low'][i] < df['Low'][i + 1] and df['Low'][i + 1] < df['Low'][i + 2] and df['Low'][i - 1] < df['Low'][i - 2]
  return support


def is_Resistance_Level(df, i):
  resistance = df['High'][i] > df['High'][i - 1] and df['High'][i] > df['High'][i + 1] and df['High'][i + 1] > df['High'][i + 2] and df['High'][i - 1] > df['High'][i - 2]
  return resistance

def plot_levels(df, ticker_symbol, levels, level_types):
  fig, ax = plt.subplots()
  candlestick_ohlc(ax, df.values, width=0.6, colorup='green', colordown='red', alpha=0.8)
  date_format = mpl_dates.DateFormatter('%d %b %Y')
  ax.xaxis.set_major_formatter(date_format)
  fig.autofmt_xdate()
  fig.tight_layout()

  for level, level_type in zip(levels, level_types):
    plt.hlines(level[1],
               xmin = df['Date'][level[0]],
               xmax = max(df['Date']),
               colors = 'blue')
    plt.text(df['Date'][level[0]], level[1], (str(level_type) + ': ' + str(level[1]) + ' '), ha='right', va='center', fontweight='bold', fontsize='x-small')
    plt.title('Support and Resistance levels for ' + ticker_symbol, fontsize=24, fontweight='bold')
    fig.show()

# plot_levels()

# This function, given a price value, returns True or False depending on if it is too near to some previously discovered key level.
def distance_from_mean(level, mean, levels):
  return np.sum([abs(level - y) < mean for y in levels]) == 0

# plot_levels()

def get_support_resistance_levels(ticker_symbol, start_date, end_date):
    try:
        # Obtaining historical stock pricing data
        ticker = yf.Ticker(ticker_symbol)

        df = ticker.history(interval='1d', start=start_date, end=end_date)

        df['Date'] = pd.to_datetime(df.index)
        df['Date'] = df['Date'].apply(mpl_dates.date2num)

        df = df.loc[:,['Date', 'Open', 'High', 'Low', 'Close']]

        # Clean noise in data by discarding a level if it is near another
        # (i.e. if distance to the next level is less than the average candle size for any given day - this will give a rough estimate on volatility)
        mean = np.mean(df['High'] - df['Low'])

        # Optimizing the analysis by adjusting the data and eliminating the noise from volatility that is causing multiple levels to show/overlapp
        levels = []
        level_types = []
        for i in range(2, df.shape[0] - 2):

            if is_Suppport_Level(df, i):
                level = df['Low'][i].round(2)

                if distance_from_mean(level, mean, levels):
                    levels.append((i, level))
                    level_types.append('Support')

            elif is_Resistance_Level(df, i):
                level = df['High'][i].round(2)

                if distance_from_mean(level, mean, levels):
                    levels.append((i, level))
                    level_types.append('Resistance')

        # print(levels)
        # plot_levels(df, ticker_symbol, levels, level_types)
        # plt.show()

        resistance_levels = []
        support_levels = []

        for i in range (len(levels)):
            if level_types[i] == 'Resistance':
                resistance_levels.append(levels[i])
            else:
                support_levels.append(levels[i])
    except Exception as e:
            print(f"Error occurred while processing stock '{ticker_symbol}': {e}")
        # print("Resistance: ", resistance_levels)
        # print("Support: ", support_levels)
    return compare_price_levels(resistance_levels, support_levels, df['Close'][-1], mean)

def compare_price_levels(resistance_levels, support_levels, current_price, mean):
    should_buy = ''
    for level in resistance_levels:
        # if abs(current_price - level[1]) < mean * 0.02:
        if abs(current_price - level[1])/current_price < 0.015:
            # print("Current price is near a resistance level:", level[1])
            should_buy = 'No'
            return should_buy

    for level in support_levels:
    #    if abs(current_price - level[1]) < mean:
        if abs(current_price - level[1])/current_price < 0.015:
            # print("Current price is near a support level:", level[1])
            should_buy = 'Yes'
            return should_buy
    return 'Maybe'

# def check_1_3_6_months(ticker_symbols):
#     stocks_waitlist = []
#     stocks_to_buy = []
#     for symbol in ticker_symbols:
#         try:
#             one_month = get_support_resistance_levels(symbol, '2023-07-01', '2023-08-10')
#             three_month = get_support_resistance_levels(symbol, '2023-05-01', '2023-08-10')
#             six_month = get_support_resistance_levels(symbol, '2023-02-01', '2023-08-10')
#         except Exception as e:
#             print(f"Error occurred while processing stock: {e}")
#         # print(one_month, ' ', three_month, ' ', six_month)
#         # if one_month == 'Yes':
#         #     if three_month == 'Yes' or six_month == 'Yes':
#         #         stocks_to_buy.append(symbol)
#         #     else:
#         #         stocks_waitlist.append(symbol)
#         # elif one_month == 'Maybe' and (three_month == 'Yes' and six_month == 'Yes'):
#         #     stocks_to_buy.append(symbol)
#         # elif one_month == 'Maybe' and three_month == 'Maybe' and six_month == 'Maybe':
#         #     stocks_to_buy.append(symbol)
#         # else:
#         #     stocks_waitlist.append(symbol)
#         if one_month == 'Yes' and three_month == 'Yes' and six_month == 'Yes':
#             stocks_to_buy.append(symbol)
#         elif one_month == 'Maybe' and three_month == 'Maybe' and six_month == 'Maybe':
#             stocks_to_buy.append(symbol)
#         else:
#             stocks_waitlist.append(symbol)
#     return stocks_to_buy, stocks_waitlist

    # print('1 month: ')
    # get_support_resistance_levels(ticker_symbol, '2023-06-01', '2023-07-10')
    # print('3 month: ')
    # get_support_resistance_levels(ticker_symbol, '2023-04-01', '2023-07-10')
    # print('6 month: ')
    # get_support_resistance_levels(ticker_symbol, '2023-01-01', '2023-07-10')


# print(check_1_3_6_months(['GWRE']))
# ticker_symbol = 'PWR'

#prioritize 1 month, then if either 3 or 6 month say yes then buy

class MyStrategy(bt.Strategy):
    params = (
        ('ma7_period', 20),
        ('ma3_period', 10),
        ('atr_period', 14),
        ('stochastic_period', 14),
        ('stochastic_smooth', 3),
        ('hma_period', 14), #7, 10
        ('trailing_stop_percent', 0.015),  # 1% trailing stop
        ('profit_target_percent', 1.8),  # Set the profit target to 1.5%
        ('stop_loss_percent', 1.0),  # Set the stop loss to 0.8%
    )

    def __init__(self, symbol):
        self.dataclose = self.datas[0].close
        self.ma7 = bt.indicators.SimpleMovingAverage(self.dataclose, period=self.params.ma7_period)
        self.ma3 = bt.indicators.SimpleMovingAverage(self.dataclose, period=self.params.ma3_period)
        self.adx = bt.indicators.AverageDirectionalMovementIndex()
        self.rsi = bt.indicators.RSI(self.dataclose, period=14)
        self.vwap = 0
        self.volume_sum = 0
        self.ema_short = bt.indicators.ExponentialMovingAverage(self.dataclose, period=10)
        self.ema_long = bt.indicators.ExponentialMovingAverage(self.dataclose, period=20)
        self.atr = bt.indicators.ATR(self.data, period=self.params.atr_period)
        self.macd = bt.indicators.MACD(self.dataclose, period_me1=12, period_me2=26, period_signal=9)
        self.momentum = bt.indicators.Momentum(self.dataclose, period=14)
        bt.indicators.FibonacciPivotPoint
        self.bollinger_bands = bt.indicators.BollingerBands(self.dataclose, period=20, devfactor=2.0)
        self.stochastic = bt.indicators.Stochastic(
            self.data,
            period=self.params.stochastic_period,
            period_dfast=self.params.stochastic_smooth,
            period_dslow=self.params.stochastic_smooth,
        )
        self.hma = bt.indicators.HullMovingAverage(self.data.close, period=self.params.hma_period)
        self.rsi_ema = bt.indicators.EMA(self.rsi, period=5)
        self.roc = bt.indicators.ROC(self.dataclose, period=14)

        # Add the WilliamsR indicator
        self.williamsr = bt.indicators.WilliamsR(period=14)
        # Initialize variables to store buy and sell prices
        self.buy_price = None
        self.sell_price = None

         # Initialize variable to track the highest price since entering the position
        self.highest_price = 1

        self.successful_trades = 0
        self.unsuccessful_trades = 0

        self.symbol = symbol

    def log_trade_info(self, txt, dt=None, price=None):
        dt = dt or self.datas[0].datetime.date(0)
        txt = f'{dt.isoformat()} - {txt}'
        if price is not None:
            txt += f' - Price: {price:.2f}'
        # print(txt)

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            return

        if order.status in [order.Completed]:
            if order.isbuy():
                self.log_trade_info('BUY EXECUTED', price=order.executed.price)
                self.buy_price = order.executed.price
            elif order.issell():
                self.log_trade_info('SELL EXECUTED', price=order.executed.price)
                self.sell_price = order.executed.price

        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log_trade_info('Order Canceled/Margin/Rejected')

    def next(self):

        if self.dataclose[0] > self.highest_price:
                self.highest_price = self.dataclose[0]

        # Calculate the trailing stop price
        trailing_stop_price = self.highest_price * (1 - self.params.trailing_stop_percent)

        # Calculate the percentage difference
        if (self.buy_price is not None) and self.position:
            percentage_diff = ((self.dataclose[0] - self.buy_price) / self.buy_price) * 100
            if self.dataclose[0] <= trailing_stop_price or percentage_diff >= self.params.profit_target_percent:
                if self.dataclose[0] > self.buy_price:
                    self.successful_trades += 1
                    self.log_trade_info('Successful Trade')
                else:
                    self.unsuccessful_trades += 1
                    self.log_trade_info('Unsuccessful Trade')
                self.sell()  # Place a sell order
                self.buy_price = None
                self.highest_price = 1  # Reset the highest price

        # Calculate VWAP
        typical_price = (self.data.high + self.data.low + self.data.close) / 3
        self.volume_sum += self.data.volume[0]
        self.vwap = (self.vwap * (self.volume_sum - self.data.volume[0]) + typical_price * self.data.volume[0]) / self.volume_sum

        if not self.position:
          # if (self.ma3[0] > self.ma7[0] and self.dataclose[0] > self.vwap
          #     and self.ema_short[0] > self.ema_long[0] and self.dataclose[0] > self.atr[0] and self.macd.macd[0] > self.macd.signal[0]
          #     and self.dataclose[0] < self.bollinger_bands.lines.top[0] and self.dataclose[0] > self.bollinger_bands.lines.mid[0]):
          if (self.rsi[0] <= 40 and self.macd.macd[0] > self.macd.signal[0] and self.hma <= self.dataclose):

              ticker_symbol = self.symbol
              try:
                  start_date = self.datas[0].datetime.date(0) - pd.DateOffset(days=30)  # Use historical data for the last year
                  end_date = self.datas[0].datetime.date(0) - pd.DateOffset(days=1)
                  result1 = get_support_resistance_levels(ticker_symbol, start_date, end_date)
                  start_date = self.datas[0].datetime.date(0) - pd.DateOffset(days=60)  # Use historical data for the last year
                  result2 = get_support_resistance_levels(ticker_symbol, start_date, end_date)
                  if result1 == 'Yes':
                      self.buy()  # Place a buy order
                      self.buy_price = self.dataclose[0]  # Store the buy price for tracking profit/loss
                      self.highest_price = self.dataclose[0]  # Initialize the highest price
              except Exception as e:
                  print(e)


        # else:
        #   if (self.dataclose[0] < self.ma7[0] and self.dataclose[0] < self.ma3[0] and self.dataclose[0] < self.vwap
        #         and self.ema_short[0] < self.ema_long[0] and self.dataclose[0] < self.atr[0] and self.macd.macd[0] < self.macd.signal[0]
        #         and self.dataclose[0] > self.bollinger_bands.lines.top[0] and self.dataclose[0] < self.bollinger_bands.lines.mid[0]):
        #         self.sell()  # Place a sell order
        #         self.sell_price = self.dataclose[0]  # Store the sell price for tracking profit/loss
        #         self.buy_price = None
          # if self.dataclose[0] > self.highest_price:
          #       self.highest_price = self.dataclose[0]

          # # Calculate the trailing stop price
          # trailing_stop_price = self.highest_price * (1 - self.params.trailing_stop_percent / 100.0)

          # # Check if the current price is below the trailing stop price (stop triggered)
          # if self.dataclose[0] <= trailing_stop_price:
          #       self.sell()  # Place a sell order
          #       self.sell_price = trailing_stop_price  # Store the sell price for tracking profit/loss
    def stop(self):
      # If there is a remaining position, sell it at the last available price
      if self.position:
          self.sell()
          self.log_trade_info('SELL EXECUTED (End of Backtest)', price=self.dataclose[0])

# Define a list of symbols to test
symbols = ['AAPL', 'GOOGL', 'MSFT', 'PBH','DEO','QCOM','SPY','MANH', 'GS','WH','JNPR','WDC','FI','UFPI','BLCO','AMN','MA','CCK','TXT','HOMB','CI','RWEOY','PRCT','HUBS','TOL','ARES','CCJ','MTZ','DQ','AXTA','INMD','VNOM','ITGR','COHU','KMTUY','KWR','HTHIY','FTV','V','ACGL','GOOG','AMT','KBR','IAC','JLL','CVS','AVY','ETN','FUTU','SLB','SPSC','JHX','BKR','WTFC','JCI','SPB','SPOT','DCBO','DINO','TTWO','UBS','LOW','TJX','BR','BSY','ABM','NVDA','SAFE','LEN','IMCR','BRBR','ZI','DOCS','BYD','CPRI']
# symbols = ['BTC']
all_successful_trades = {}
all_unsuccessful_trades = {}
for symbol in symbols:
  # Download historical data using yfinance
  data = yf.download(symbol, start='2023-06-01', end='2024-0-01')  # Replace with the desired start and end dates

  # Convert the DataFrame to a backtrader-compatible data feed
  data_feed = bt.feeds.PandasData(dataname=data)

  # Instantiate the Cerebro engine
  cerebro = bt.Cerebro()

  # Add the data feed to the engine
  cerebro.adddata(data_feed)

  # Add your strategy to the engine
  cerebro.addstrategy(MyStrategy, symbol=symbol)

  # Set the initial capital and position size
  cerebro.broker.setcash(10000)
  # cerebro.addsizer(bt.sizers.FixedSize, stake=10)
  cerebro.addsizer(bt.sizers.PercentSizer, percents=100)
  # Run the backtest
  cerebro.run()

  strategy = cerebro.runstrats[0][0]  # Access the strategy object correctly
  all_successful_trades[symbol] = strategy.successful_trades
  all_unsuccessful_trades[symbol] = strategy.unsuccessful_trades

  # Print the final portfolio value
  print('Stock Symbol: ', symbol)
  print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())
  print('profit/loss %: ', ((cerebro.broker.getvalue()-10000)/10000)*100)
  print('Successful trades:', all_successful_trades[symbol])
  print('Unsuccessful trades:', all_unsuccessful_trades[symbol])

total_successful_trades = sum(all_successful_trades.values())
total_unsuccessful_trades = sum(all_unsuccessful_trades.values())
print("Total Successful Trades:", total_successful_trades)
print("Total Unsuccessful Trades:", total_unsuccessful_trades)
# print('============================================')
# print('2022')
# for symbol in symbols:
#   # Download historical data using yfinance
#   data = yf.download(symbol, start='2022-01-01', end='2023-01-01')  # Replace with the desired start and end dates

#   # Convert the DataFrame to a backtrader-compatible data feed
#   data_feed = bt.feeds.PandasData(dataname=data)

#   # Instantiate the Cerebro engine
#   cerebro = bt.Cerebro()

#   # Add the data feed to the engine
#   cerebro.adddata(data_feed)

#   # Add your strategy to the engine
#   cerebro.addstrategy(MyStrategy, symbol=symbol)

#   # Set the initial capital and position size
#   cerebro.broker.setcash(10000)
#   # cerebro.addsizer(bt.sizers.FixedSize, stake=10)
#   cerebro.addsizer(bt.sizers.PercentSizer, percents=100)

#   # Run the backtest
#   cerebro.run()

#   strategy = cerebro.runstrats[0][0]  # Access the strategy object correctly
#   all_successful_trades[symbol] = strategy.successful_trades
#   all_unsuccessful_trades[symbol] = strategy.unsuccessful_trades

#   # Print the final portfolio value
#   print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())
#   print('profit/loss %: ', ((cerebro.broker.getvalue()-10000)/10000)*100)

# # Calculate the total successful and unsuccessful trades across all symbols
# total_successful_trades2 = sum(all_successful_trades.values())
# total_unsuccessful_trades2 = sum(all_unsuccessful_trades.values())

# total_successful_trades = total_successful_trades + total_successful_trades2
# total_unsuccessful_trades = total_unsuccessful_trades +total_unsuccessful_trades2
# # Print the total number of successful and unsuccessful trades
# print("Total Successful Trades:", total_successful_trades)
# print("Total Unsuccessful Trades:", total_unsuccessful_trades)

"""Total Successful Trades: 25
Total Unsuccessful Trades: 10



```
self.macd.macd[0] > self.macd.signal[0] and self.ema_short[0] > self.ema_long[0] and self.dataclose[0] > self.atr[0]
              and self.stochastic.lines.percK[0] > self.stochastic.lines.percD[0] and self.dataclose[0] > self.vwap
              and self.dataclose[0] < self.bollinger_bands.lines.top[0] and self.dataclose[0] > self.bollinger_bands.lines.mid[0]
              and self.hma[0] > self.hma[-1] and self.hma[-1] < self.hma[-2] and self.momentum > 0
```

Optimization
"""

class MyStrategy(bt.Strategy):
    params = (
        ('ma7_period', 5),
        ('ma3_period', 3),
        ('atr_period', 7),
        ('stochastic_period', 14),
        ('stochastic_smooth', 3),
        ('hma_period', 10), #7, 10
        ('trailing_stop_percent', 0.01),  # 1% trailing stop
    )

    def __init__(self, symbol):
        self.dataclose = self.datas[0].close
        self.ma7 = bt.indicators.SimpleMovingAverage(self.dataclose, period=self.params.ma7_period)
        self.ma3 = bt.indicators.SimpleMovingAverage(self.dataclose, period=self.params.ma3_period)
        self.adx = bt.indicators.AverageDirectionalMovementIndex()
        self.rsi = bt.indicators.RSI(self.dataclose, period=11)
        self.vwap = 0
        self.volume_sum = 0
        self.ema_short = bt.indicators.ExponentialMovingAverage(self.dataclose, period=3)
        self.ema_long = bt.indicators.ExponentialMovingAverage(self.dataclose, period=5)
        self.atr = bt.indicators.ATR(self.data, period=self.params.atr_period)
        self.macd = bt.indicators.MACD(self.dataclose, period_me1=12, period_me2=26, period_signal=9)
        self.momentum = bt.indicators.Momentum(self.dataclose, period=3)

        self.bollinger_bands = bt.indicators.BollingerBands(self.dataclose, period=20, devfactor=2.0)
        self.stochastic = bt.indicators.Stochastic(
            self.data,
            period=self.params.stochastic_period,
            period_dfast=self.params.stochastic_smooth,
            period_dslow=self.params.stochastic_smooth,
        )
        self.hma = bt.indicators.HullMovingAverage(self.data.close, period=self.params.hma_period)
        self.rsi_ema = bt.indicators.EMA(self.rsi, period=5)
        # Initialize variables to store buy and sell prices
        self.buy_price = None
        self.sell_price = None

         # Initialize variable to track the highest price since entering the position
        self.highest_price = 1

        self.successful_trades = 0
        self.unsuccessful_trades = 0

        self.symbol = symbol

    def log_trade_info(self, txt, dt=None, price=None):
        dt = dt or self.datas[0].datetime.date(0)
        txt = f'{dt.isoformat()} - {txt}'
        if price is not None:
            txt += f' - Price: {price:.2f}'
        # print(txt)

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            return

        if order.status in [order.Completed]:
            if order.isbuy():
                self.log_trade_info('BUY EXECUTED', price=order.executed.price)
                self.buy_price = order.executed.price
            elif order.issell():
                self.log_trade_info('SELL EXECUTED', price=order.executed.price)
                self.sell_price = order.executed.price

        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log_trade_info('Order Canceled/Margin/Rejected')

    def next(self):

        if self.dataclose[0] > self.highest_price:
                self.highest_price = self.dataclose[0]

        # Calculate the trailing stop price
        trailing_stop_price = self.highest_price * (1 - self.params.trailing_stop_percent)

        # Calculate the percentage difference
        if (self.buy_price is not None) and self.position:
            percentage_diff = (self.dataclose[0] - self.buy_price) / self.buy_price * 100
            if self.dataclose[0] <= trailing_stop_price:
                if self.dataclose[0] > self.buy_price:
                  self.successful_trades += 1
                  # print('successful: ', self.successful_trades)
                else:
                  self.unsuccessful_trades += 1
                  # print('unnnnnnsuccessful: ', self.unsuccessful_trades)
                self.sell()  # Place a sell order
                self.buy_price = None
                # print('loss')
            # Check if the percentage difference exceeds 1% (positive or negative)
            # if percentage_diff <= -0.6:
            #     print('loss')
            #     self.sell()
            #     self.buy_price = None
            if percentage_diff >= 1.5:
                self.successful_trades += 1
                # print('successful: ', self.successful_trades)
                self.sell()
                self.buy_price = None
                # print('profit')

        # Calculate VWAP
        typical_price = (self.data.high + self.data.low + self.data.close) / 3
        self.volume_sum += self.data.volume[0]
        self.vwap = (self.vwap * (self.volume_sum - self.data.volume[0]) + typical_price * self.data.volume[0]) / self.volume_sum

        if not self.position:
          # if (self.ma3[0] > self.ma7[0] and self.dataclose[0] > self.vwap
          #     and self.ema_short[0] > self.ema_long[0] and self.dataclose[0] > self.atr[0] and self.macd.macd[0] > self.macd.signal[0]
          #     and self.dataclose[0] < self.bollinger_bands.lines.top[0] and self.dataclose[0] > self.bollinger_bands.lines.mid[0]):
          if (self.macd.macd[0] > self.macd.signal[0] and self.ema_short[0] > self.ema_long[0] and self.dataclose[0] > self.atr[0]
              and self.stochastic.lines.percK[0] > self.stochastic.lines.percD[0] and self.dataclose[0] > self.vwap
              and self.dataclose[0] < self.bollinger_bands.lines.top[0] and self.dataclose[0] > self.bollinger_bands.lines.mid[0]
              and self.hma[0] > self.hma[-1] and self.hma[-1] < self.hma[-2] and self.momentum > 0):

              ticker_symbol = self.symbol
              start_date = self.datas[0].datetime.date(0) - pd.DateOffset(days=30)  # Use historical data for the last year
              end_date = self.datas[0].datetime.date(0) - pd.DateOffset(days=1)
              result1 = get_support_resistance_levels(ticker_symbol, start_date, end_date)
              start_date = self.datas[0].datetime.date(0) - pd.DateOffset(days=90)  # Use historical data for the last year
              result2 = get_support_resistance_levels(ticker_symbol, start_date, end_date)
              if result1 == 'Yes' or result2 == 'Yes':
                self.buy()  # Place a buy order
                self.buy_price = self.dataclose[0]  # Store the buy price for tracking profit/loss
                self.highest_price = self.dataclose[0]  # Initialize the highest price


        # else:
        #   if (self.dataclose[0] < self.ma7[0] and self.dataclose[0] < self.ma3[0] and self.dataclose[0] < self.vwap
        #         and self.ema_short[0] < self.ema_long[0] and self.dataclose[0] < self.atr[0] and self.macd.macd[0] < self.macd.signal[0]
        #         and self.dataclose[0] > self.bollinger_bands.lines.top[0] and self.dataclose[0] < self.bollinger_bands.lines.mid[0]):
        #         self.sell()  # Place a sell order
        #         self.sell_price = self.dataclose[0]  # Store the sell price for tracking profit/loss
        #         self.buy_price = None
          # if self.dataclose[0] > self.highest_price:
          #       self.highest_price = self.dataclose[0]

          # # Calculate the trailing stop price
          # trailing_stop_price = self.highest_price * (1 - self.params.trailing_stop_percent / 100.0)

          # # Check if the current price is below the trailing stop price (stop triggered)
          # if self.dataclose[0] <= trailing_stop_price:
          #       self.sell()  # Place a sell order
          #       self.sell_price = trailing_stop_price  # Store the sell price for tracking profit/loss
    def stop(self):
      # If there is a remaining position, sell it at the last available price
      if self.position:
          self.sell()
          self.log_trade_info('SELL EXECUTED (End of Backtest)', price=self.dataclose[0])
# Define a list of symbols to test
symbols = ['AAPL', 'GOOGL', 'MSFT', 'PBH','DEO','QCOM','SPY','MANH']

# Define a list of parameter combinations to test
# parameters = {
#     'ma7_period': [5, 7, 10, 14, 20],
#     'ma3_period': [2, 3, 5, 10],
#     'atr_period': [3, 5, 7, 14, 21],
#     'ema_short_period': [3,5,7],
#     'ema_long_period': [5,7,10,14],
#     'momentum': [3,5,7,10,14]
# }

# parameters = {
#     'ma7_period': [5, 7],
#     'ma3_period': [3, 10],
#     'atr_period': [5, 7],
#     'ema_short_period': [3,5,7],
#     'ema_long_period': [7,10,14],
#     'momentum': [7,10,14]
# }

parameters = {
    'hma_short_period': [3, 5, 7, 10, 14],
    'hma_long_period': [5, 7, 10, 14, 20]
}

# Generate all combinations of parameters
param_combinations = list(itertools.product(*parameters.values()))

# Initialize a dictionary to store the best parameters and best portfolio value for each stock
best_params_and_success_rate = {}

# Iterate over each symbol and parameter combination
for symbol in symbols:
    for params in param_combinations:
        # Download historical data using yfinance
        data = yf.download(symbol, start='2022-01-01', end='2023-08-01')

        # Convert the DataFrame to a backtrader-compatible data feed
        data_feed = bt.feeds.PandasData(dataname=data)

        # Instantiate the Cerebro engine
        cerebro = bt.Cerebro()

        # Add the data feed to the engine
        cerebro.adddata(data_feed)

        # Add your strategy to the engine with the specified parameters
        # cerebro.addstrategy(MyStrategy, ma7_period=params[0], ma3_period=params[1], atr_period=params[2], ema_short_period=params[3],ema_long_period=params[4],momentum=params[5])
        cerebro.addstrategy(MyStrategy, symbol=symbol, hma_short_period=params[0], hma_long_period=params[1])

        # Set the initial capital and position size
        cerebro.broker.setcash(10000)
        cerebro.addsizer(bt.sizers.FixedSize, stake=10)

        # Run the backtest
        cerebro.run()
        strategy = cerebro.runstrats[0][0]  # Access the strategy object correctly
        # Get the final portfolio value
        final_portfolio_value = cerebro.broker.getvalue()
        all_successful_trades[symbol] = strategy.successful_trades
        all_unsuccessful_trades[symbol] = strategy.unsuccessful_trades

        # Check if no trades were made
        if all_successful_trades[symbol] == 0 and all_unsuccessful_trades[symbol] == 0:
            success_rate = 0
            final_portfolio_value = None
        else:
          success_rate = all_successful_trades[symbol]/(all_successful_trades[symbol] + all_unsuccessful_trades[symbol])

        if success_rate > best_params_and_success_rate.get(symbol, (None, 0))[1]:
            best_params_and_success_rate[symbol] = (params, success_rate, final_portfolio_value)

print('Best Parameters, Success Rate, and Final Price for Each Stock:')
for symbol, (params, success_rate, final_portfolio_value) in best_params_and_success_rate.items():
    print(f'Stock Symbol: {symbol}')
    print('Best Parameters:', params)
    print('Success Rate: {:.2%}'.format(success_rate))
    if final_portfolio_value is not None:
        print('Final Price: {:.2f}'.format(final_portfolio_value))
    else:
        print('No trades were made.')
    print('--------------')

"""Stock Symbol: GOOGL
Best Parameters: (3,)
Success Rate: 100.00%
Final Price: 10025.39
--------------
Stock Symbol: MSFT
Best Parameters: (5,)
Success Rate: 100.00%
Final Price: 10086.80
--------------
Stock Symbol: PBH
Best Parameters: (14,)
Success Rate: 100.00%
Final Price: 10041.90
--------------
Stock Symbol: DEO
Best Parameters: (5,)
Success Rate: 100.00%
Final Price: 10033.90
--------------
Stock Symbol: QCOM
Best Parameters: (3,)
Success Rate: 100.00%
Final Price: 10014.20
--------------
Stock Symbol: SPY
Best Parameters: (3,)
Success Rate: 100.00%
Final Price: 10075.30
--------------
Stock Symbol: MANH
Best Parameters: (3,)
Success Rate: 100.00%
Final Price: 10040.90
--------------

"""